const { EmbedBuilder, MessageFlags } = require('discord.js');
const User = require('../models/User');
const Game = require('../utils/game');

module.exports = {
  name: 'interactionCreate',
  async execute(interaction, client) {
    if (interaction.isCommand()) {
      const command = client.commands.get(interaction.commandName);
      if (!command) return;

      try {
        await command.execute(interaction);
      } catch (error) {
        console.error(`L·ªói l·ªánh ${interaction.commandName}:`, error);
        await interaction.reply({ 
          content: '‚ùå L·ªói th·ª±c thi l·ªánh!', 
          flags: MessageFlags.Ephemeral 
        });
      }
      return;
    }

    if (interaction.isButton()) {
      try {
        if (interaction.customId === 'game_history') {
          const history = client.gameHistory?.get(interaction.channelId) || [];
          const historyEmbed = new EmbedBuilder()
            .setTitle('üìú L·ªäCH S·ª¨ 5 PHI√äN G·∫¶N NH·∫§T')
            .setColor(0x6B8E23)
            .setDescription(
              history.slice(-5).reverse().map((game, idx) => 
                `**#${idx + 1}** ${game.dice} ¬ª **${game.sum}** (${game.result})\n‚è±Ô∏è ${game.time}`
              ).join('\n\n') || 'Ch∆∞a c√≥ l·ªãch s·ª≠'
            );
          
          return interaction.reply({ 
            embeds: [historyEmbed], 
            flags: MessageFlags.Ephemeral 
          });
        }

        const game = client.games.get(interaction.channelId);
        if (!game || game.status !== 'open') {
          return interaction.reply({ 
            content: '‚è≥ Phi√™n ƒë√£ k·∫øt th√∫c!', 
            flags: MessageFlags.Ephemeral 
          });
        }

        const [type, amount, choice] = interaction.customId.split('_').slice(1);
        
        if (game.bets.some(b => b.userId === interaction.user.id)) {
          return interaction.reply({ 
            content: '‚ùå M·ªói ng∆∞·ªùi ch·ªâ ƒë∆∞·ª£c c∆∞·ª£c 1 l·∫ßn!', 
            flags: MessageFlags.Ephemeral 
          });
        }

        if (type === 'tai' || type === 'xiu') {
          await game.createBetOptions(interaction, type);
          return;
        }

        if (type === 'amount') {

          const user = await User.findOneAndUpdate(
            { userId: interaction.user.id },
            { $setOnInsert: { balance: 10000 } },
            { upsert: true, new: true }
          );
      
          // X·ª≠ l√Ω modal submit
    if (interaction.isModalSubmit()) {
      await interaction.deferReply({ ephemeral: true }); // Th√™m d√≤ng n√†y
      try {
        const [_, choice] = interaction.customId.split('_').slice(1);
        const game = client.games.get(interaction.channelId);
        
        if (!game || game.status !== 'open') {
          return interaction.reply({ 
            content: '‚è≥ Phi√™n c∆∞·ª£c ƒë√£ k·∫øt th√∫c!', 
            ephemeral: true 
          });
        }

        const userInput = interaction.fields.getTextInputValue('bet_amount');
        const user = await User.findOne({ userId: interaction.user.id });
        const input = interaction.fields.getTextInputValue('bet_amount');
        
       // X·ª≠ l√Ω gi√° tr·ªã nh·∫≠p
       let amount;
       if (input.toLowerCase().match(/^(all|max)$/)) {
         amount = user.balance;
       } else {
         // X·ª≠ l√Ω c√°c ƒë·ªãnh d·∫°ng s·ªë (1k = 1000, 2.5k = 2500)
         const numberValue = input.toLowerCase().replace(/[^0-9.k]/g, '');
         amount = Math.round(parseFloat(numberValue.replace('k', '')) * 1000) || 0;
       }

        // Validate
        if (isNaN(amount) || amount < 100) {
          return interaction.reply({
            content: '‚ùå S·ªë ti·ªÅn t·ªëi thi·ªÉu l√† 100 coins!',
            ephemeral: true
          });
        }

        if (amount > user.balance) {
          return interaction.reply({
            content: `‚ùå B·∫°n ch·ªâ c√≥ ${user.balance.toLocaleString()} coins!`,
            ephemeral: true
          });
        }

        // Th√™m c∆∞·ª£c
        game.bets.push({
          userId: interaction.user.id,
          amount: amount,
          choice: choice
        });

        // X√°c nh·∫≠n
        await interaction.editReply({
          content: `‚úÖ ƒê√£ ƒë·∫∑t **${amount.toLocaleString()} coins** v√†o **${choice.toUpperCase()}**!`,
          ephemeral: true
        });

        // C·∫≠p nh·∫≠t embed
        await game.updateEmbed();

      } catch (error) {
        console.error('L·ªói x·ª≠ l√Ω ƒë·∫∑t c∆∞·ª£c:', error);
        await interaction.editReply({
          content: '‚ùå L·ªói x·ª≠ l√Ω ƒë·∫∑t c∆∞·ª£c!',
          ephemeral: true
        });
      }
    }

  const amountValue = amount === 'All' ? user.balance : parseInt(amount);
  
  if (isNaN(amountValue) || amountValue < 100 || amountValue > user.balance) {
    return interaction.reply({ 
      content: `‚ùå B·∫°n kh√¥ng c√≥ ƒë·ªß ti·ªÅn - c√≤n l·∫°i: ${user.balance.toLocaleString()}!`,
      flags: MessageFlags.Ephemeral 
    });
  }

          game.bets.push({
  userId: interaction.user.id,
  amount: amountValue,
  choice: choice === 'tai' ? 't√†i' : 'x·ªâu' // Th√™m ph·∫ßn chu·∫©n h√≥a n√†y
});

          await game.updateEmbed();
          await interaction.followUp({
            content: `‚úÖ ƒê√£ ƒë·∫∑t **${amountValue.toLocaleString()} coins** v√†o **${choice.toUpperCase()}**!`,
            flags: MessageFlags.Ephemeral 
          });
        }
      } catch (error) {
        console.error('L·ªói x·ª≠ l√Ω button:', error);
        await interaction.followUp({ 
          content: '‚ùå L·ªói h·ªá th·ªëng!', 
          flags: MessageFlags.Ephemeral 
        });
      }
    }
  }
};